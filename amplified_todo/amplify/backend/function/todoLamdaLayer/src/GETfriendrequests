from datetime import datetime
import json
import os
import logging
import boto3
from boto3.dynamodb.conditions import Key, Attr



USER_TABLE = os.environ.get("API_DEMIAPP_USERTABLE_NAME")
FRIENDSHIP_TABLE = os.environ.get("API_DEMIAPP_FRIENDSHIPTABLE_NAME")
S3_BUCKET_NAME = os.environ.get("STORAGE_S3DEMIUSERPROFILEPICTURES_BUCKETNAME")
REQUEST_HTTP_METHOD_FIELD = "httpMethod"
REQUEST_QS_PARAMS_FIELD = "queryStringParameters"

QS_USER_ID = "userId"

# TABLE COLUMNS
FRIENDSHIP_COL_ID = "id"
FRIENDSHIP_COL_SENT_ID = "senderUserId"
FRIENDSHIP_COL_RECEIVED_ID = "receiverUserId"
FRIENDSHIP_COL_CONFIRMED = "confirmed"

USER_COL_ID = "id"
USER_COL_FIRSTNAME = "firstName"
USER_COL_LASTNAME = "lastName"
USER_COL_USERNAME = "username"

logger = logging.getLogger()
logger.setLevel(logging.INFO)
dynamodb = boto3.resource('dynamodb')
s3 = boto3.client('s3')
user_table = dynamodb.Table(USER_TABLE)
friendship_table = dynamodb.Table(FRIENDSHIP_TABLE)

def handler(event, context):
    logger.info(f'## ENVIRONMENT VARIABLES:\n{os.environ}')
    logger.info(f'## EVENT:\n{event}')

    http_verb = event[REQUEST_HTTP_METHOD_FIELD]

    if http_verb == "GET": 
        try:
            qs_param_dict = event[REQUEST_QS_PARAMS_FIELD]
            if validate_qs_params(qs_param_dict):
                user_id = qs_param_dict[QS_USER_ID]
                
                received_unconfirmed_friendships = get_friend_requests(user_id)

                friend_request_user_ids = list(map(lambda f: f[FRIENDSHIP_COL_SENT_ID], received_unconfirmed_friendships))

                friend_requests_users = get_friend_requests_user_data(friend_request_user_ids)
                            
                transformed_user_data = transform_friend_request_user_data(friend_requests_users, received_unconfirmed_friendships)

                return make_return_obj(200, json.dumps([u.toJSON() for u in transformed_user_data], default=str))
            
            else:
                logger.error(f"Bad QS params")
                return make_return_obj(400, "Error retrieving addable friends")

        except Exception as e:
            logger.exception(repr(e))
            return make_return_obj(500, "Error getting data for friends to add")

    else:
        return make_return_obj(400, "Invalid http request")


def make_return_obj(statusCode, body):
  return {
    'statusCode': statusCode,
    'headers': {
      'Access-Control-Allow-Headers': '*',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'OPTIONS,POST,GET'
    },
    'body': body
  }

def validate_qs_params(qs_param_dict: dict):
    is_valid = True
    try:
        if len(qs_param_dict.keys()) != 1 :
            is_valid=False
        if not (isinstance(qs_param_dict[QS_USER_ID], str) and (len(qs_param_dict[QS_USER_ID]) < 50)):
            is_valid=False

    except Exception as e:
        logger.exception(repr(e))

    return is_valid

def get_friend_requests(user_id: str):

    response = friendship_table.scan(
        FilterExpression=(Attr(FRIENDSHIP_COL_CONFIRMED).eq(False) & 
                          Attr(FRIENDSHIP_COL_RECEIVED_ID).eq(user_id))
    )
    
    return response["Items"]

def get_friend_requests_user_data(friend_request_user_ids: list):

    response = user_table.scan(
        FilterExpression=(Attr(USER_COL_ID).is_in(friend_request_user_ids))
    )

    return response["Items"]

def transform_friend_request_user_data(friend_requests_users: list, received_unconfirmed_friendships: list):
    transformed_data = []

    # Build map of friend requestor's userId to friendshipId
    userid_friendshipid_map = {}
    for received_unconfirmed_friendship in received_unconfirmed_friendships:
        userid_friendshipid_map[received_unconfirmed_friendship[FRIENDSHIP_COL_SENT_ID]] = received_unconfirmed_friendship[FRIENDSHIP_COL_ID]

    for user_data in friend_requests_users:
        profile_picture_url = get_profile_picture_url(user_data[USER_COL_ID])
        friendshipId = userid_friendshipid_map[user_data[USER_COL_ID]]

        transformed_data.append(
            FriendRequestUserDisplayData(user_data[USER_COL_ID],
                                        user_data[USER_COL_FIRSTNAME],
                                        user_data[USER_COL_LASTNAME],
                                        user_data[USER_COL_USERNAME],
                                        profile_picture_url,
                                        friendshipId,
            )
        )

    return transformed_data

def get_profile_picture_url(user_id):
    presigned_url = "noProfilePicture"
    try:
        key = f"public/userProfilePictures/{user_id}/profilePicure.jpeg"
        presigned_url = s3.generate_presigned_url('get_object', 
                                                    Params = 
                                                        {'Bucket': S3_BUCKET_NAME,  
                                                        'Key': key}, 
                                                    ExpiresIn = 3600
                                                    )
    except Exception as e:
        logger.exception(e)
        logger.info(f"No profile picture found for user {user_id}")

    return presigned_url

class FriendRequestUserDisplayData():
    def __init__(self, id: str, firstName: str, lastName: str, username: str, profilePictureUrl: str, friendshipId: str):
        self.id = id
        self.firstName = firstName
        self.lastName = lastName
        self.username = username
        self.profilePictureUrl = profilePictureUrl
        self.friendshipId = friendshipId
    
    def toJSON(self):
        return {
            USER_COL_ID: self.id,
            USER_COL_FIRSTNAME: self.firstName,
            USER_COL_LASTNAME: self.lastName,
            USER_COL_USERNAME: self.username,
            "profilePictureUrl": self.profilePictureUrl,
            "friendshipId": self.friendshipId
        }
    