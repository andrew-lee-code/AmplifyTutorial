import json
import os
import logging
import math
import boto3
from boto3.dynamodb.conditions import Key, Attr

BIN_TABLE = os.environ.get("API_DEMIAPP_BINTABLE_NAME")
USER_TABLE = os.environ.get("API_DEMIAPP_USERTABLE_NAME")
FRIENDSHIP_TABLE = os.environ.get("API_DEMIAPP_FRIENDSHIPTABLE_NAME")
BUILDING_TABLE = os.environ.get("API_DEMIAPP_BUILDINGTABLE_NAME")
USER_BUILDING_UNIT_TABLE = os.environ.get("API_DEMIAPP_USERBUILDINGUNITTABLE_NAME")
S3_BUCKET_NAME = os.environ.get("STORAGE_S3DEMIUSERPROFILEPICTURES_BUCKETNAME")
REQUEST_HTTP_METHOD_FIELD = "httpMethod"
REQUEST_QS_PARAMS_FIELD = "queryStringParameters"

QS_PARAMS ={
    "userId": "userId",
    "scope": "scope",
    "top": "top"
}

SCOPE_ENUM = {
    "friends": "friends",
    "building": "building"
}

BIN_TABLE_COLUMNS = {
    "id": "id",
    "userID": "userID",
    "weightLb": "weightLb",
    "status": "status"
}

BIN_STATUS_ENUM = {
    "UNCLAIMED": "UNCLAIMED",
    "CLAIMED": "CLAIMED",
    "AWAITING_PICKUP": "AWAITING_PICKUP",
    "PICKED_UP": "PICKED_UP",
    "WEIGHED" : "WEIGHED",
    "COMPOSTED" : "COMPOSTED"
}

USER_TABLE_COLUMNS = {
    "id": "id",
    "firstName": "firstName",
    "lastName": "lastName",
    "username": "username",
}

FRIENDSHIP_TABLE_COLUMNS = {
    "senderUserId": "senderUserId",
    "receiverUserId": "receiverUserId",
    "confirmed": "confirmed"
}

BUILDING_TABLE_COLUMNS = {
    "id": "id"
}

USER_BUILDING_UNIT_TABLE_COLUMNS = {
    "userID": "userID",
    "buildingUnitID": "buildingUnitID",
    "buildingID": "buildingID"
}

logger = logging.getLogger()
logger.setLevel(logging.INFO)
dynamodb = boto3.resource('dynamodb')
s3 = boto3.client('s3')
user_table = dynamodb.Table(USER_TABLE)
bin_table = dynamodb.Table(BIN_TABLE)
friendship_table = dynamodb.Table(FRIENDSHIP_TABLE)
building_table = dynamodb.Table(BUILDING_TABLE)
user_building_unit_table = dynamodb.Table(USER_BUILDING_UNIT_TABLE)


def handler(event, context):
    logger.info(f'## ENVIRONMENT VARIABLES:\n{os.environ}')
    logger.info(f'## EVENT:\n{event}')

    http_verb = event[REQUEST_HTTP_METHOD_FIELD]

    if http_verb == "GET": 
        try:
            qs_param_dict = event[REQUEST_QS_PARAMS_FIELD]
            if validate_qs_params(qs_param_dict):
                user_id = qs_param_dict[QS_PARAMS["userId"]]
                scope = qs_param_dict[QS_PARAMS["scope"]]
                num_to_show = qs_param_dict[QS_PARAMS["top"]] #TODO: implement this

                leaderboard_data = []
                if scope == SCOPE_ENUM["building"]:
                    leaderboard_data = get_building_leaderboard_data(user_id)
                if scope == SCOPE_ENUM["friends"]:
                    leaderboard_data = get_friends_leaderboard_data(user_id)

                return make_return_obj(200, json.dumps([l.toJSON() for l in leaderboard_data], default=str))
            
            else:
                logger.error(f"Bad QS params")
                return make_return_obj(400, "Error getting leaderboard data")

        except Exception as e:
            logger.exception(repr(e))
            return make_return_obj(500, "Error getting leaderboard data")

    else:
        logger.error(f"Invalid HTTP request")
        return make_return_obj(400, "Error getting leaderboard data")


def make_return_obj(statusCode, body):
  return {
    'statusCode': statusCode,
    'headers': {
      'Access-Control-Allow-Headers': '*',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'OPTIONS,POST,GET'
    },
    'body': body
  }

def validate_qs_params(qs_param_dict: dict):
    is_valid = True
    try:
        if len(qs_param_dict.keys()) != 3:
            is_valid=False
        if not (isinstance(qs_param_dict[QS_PARAMS["userId"]], str) 
                and (len(qs_param_dict[QS_PARAMS["userId"]]) < 50)
                and qs_param_dict[QS_PARAMS["userId"]]):
            is_valid=False
        if not (isinstance(qs_param_dict[QS_PARAMS["scope"]], str)
                and (qs_param_dict[QS_PARAMS["scope"]] in SCOPE_ENUM.keys())):
            is_valid=False
        if not str.isnumeric(qs_param_dict[QS_PARAMS["top"]]):
            is_valid=False

    except Exception as e:
        logger.exception(repr(e))

    return is_valid

def get_bin_data_for_user(user_id: str):

    response = friendship_table.scan(
        FilterExpression=(Attr(BIN_TABLE_COLUMNS["userID"]).eq(user_id))
    )
    
    # Filter for bins with non-zero weights and that have been marked weighed or composted
    return_data = list(filter(lambda b: b[BIN_TABLE_COLUMNS["weightLb"]] != None and 
                          b[BIN_TABLE_COLUMNS["weightLb"]] > 0 and
                          b[BIN_TABLE_COLUMNS["status"]] in [BIN_STATUS_ENUM["WEIGHED"], BIN_STATUS_ENUM["COMPOSTED"]],
                          response["Items"]))
   
    return return_data

def get_friends_leaderboard_data(user_id: str):

    return_data = []

    confirmed_friendships = friendship_table.scan(
        FilterExpression=((Attr(FRIENDSHIP_TABLE_COLUMNS["senderUserId"]).eq(user_id) |
                            Attr(FRIENDSHIP_TABLE_COLUMNS["receiverUserId"]).eq(user_id)) &
                            Attr(FRIENDSHIP_TABLE_COLUMNS["confirmed"]).eq(True))
    )

    friend_user_ids = list(map(lambda f: f[FRIENDSHIP_TABLE_COLUMNS["receiverUserId"]], confirmed_friendships)).extend(
        list(map(lambda f: f[FRIENDSHIP_TABLE_COLUMNS["senderUserId"]], confirmed_friendships))
    )

    friend_user_ids = list(dict.fromkeys(friend_user_ids))

    for friend_user_id in friend_user_ids:
        user_data = user_table.scan(
            FilterExpression=Attr(USER_TABLE_COLUMNS["id"]).eq(friend_user_id)
        )
        bin_data = get_bin_data_for_user(friend_user_id)

        user_data = user_data["Items"][0]
        bin_data = bin_data["Items"]
        
        leaderboard_data = LeaderboardUserData(
            user_data[USER_TABLE_COLUMNS["id"]],
            user_data[USER_TABLE_COLUMNS["firstName"]],
            user_data[USER_TABLE_COLUMNS["username"]],
            get_profile_picture_url(user_data[USER_TABLE_COLUMNS["id"]]),
            calculate_total_compost_weight(bin_data)
        )
        return_data.append(leaderboard_data)
    
    return return_data
    


def get_building_leaderboard_data(user_id: str):
    return_data =[]

    user_building_unit_linkage = user_building_unit_table.scan(
        FilterExpression=(Attr(USER_BUILDING_UNIT_TABLE_COLUMNS["userID"]).eq(user_id))
    )
    building_id = user_building_unit_linkage["Items"][0][USER_BUILDING_UNIT_TABLE_COLUMNS["buildingID"]]

    all_building_units = user_building_unit_table.scan(
        FilterExpression=(Attr(USER_BUILDING_UNIT_TABLE_COLUMNS["buildingID"]).eq(building_id))
    )
    neighbor_user_ids = list(map(lambda b: b[USER_BUILDING_UNIT_TABLE_COLUMNS["userID"]],all_building_units["Items"]))

    for neighbor_user_id in neighbor_user_ids:
        user_data = user_table.scan(
            FilterExpression=Attr(USER_TABLE_COLUMNS["id"]).eq(neighbor_user_id)
        )
        bin_data = get_bin_data_for_user(neighbor_user_id)

        user_data = user_data["Items"][0]
        bin_data = bin_data["Items"]

        leaderboard_data = LeaderboardUserData(
            user_data[USER_TABLE_COLUMNS["id"]],
            user_data[USER_TABLE_COLUMNS["firstName"]],
            user_data[USER_TABLE_COLUMNS["username"]],
            get_profile_picture_url(user_data[USER_TABLE_COLUMNS["id"]]),
            calculate_total_compost_weight(bin_data)
        )
        return_data.append(leaderboard_data)
    
    return return_data

def get_profile_picture_url(user_id):
    presigned_url = "noProfilePicture"
    try:
        key = f"public/userProfilePictures/{user_id}/profilePicure.jpeg"
        presigned_url = s3.generate_presigned_url('get_object', 
                                                    Params = 
                                                        {'Bucket': S3_BUCKET_NAME,  
                                                        'Key': key}, 
                                                    ExpiresIn = 3600
                                                    )
    except Exception as e:
        logger.exception(e)
        logger.info(f"No profile picture found for user {user_id}")

    return presigned_url

def calculate_total_compost_weight(bins_in_scope: list):
    total_weight = 0
    for bin in bins_in_scope:
        total_weight = total_weight + bin[BIN_TABLE_COLUMNS["weightLb"]]
    
    # TODO: round this to a single decimal point
    return total_weight

class LeaderboardUserData():
    def __init__(self, id: str, firstName: str, lastName: str, username: str, profilePictureUrl: str, weightComposted: float):
        self.id = id
        self.firstName = firstName
        self.lastName = lastName
        self.username = username
        self.profilePictureUrl = profilePictureUrl
        self.weightComposted = weightComposted
    
    def toJSON(self):
        return {
            "id": self.id,
            "firstName": self.firstName,
            "lastName": self.lastName,
            "username": self.username,
            "profilePictureUrl": self.profilePictureUrl,
            "weightComposted": self.weightComposted
        }
    
    